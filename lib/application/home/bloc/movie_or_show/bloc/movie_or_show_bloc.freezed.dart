// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'movie_or_show_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$MovieOrShowEventTearOff {
  const _$MovieOrShowEventTearOff();

// ignore: unused_element
  BookmarkPressed bookmarkPressed() {
    return const BookmarkPressed();
  }

// ignore: unused_element
  WatchedPressed watchedPressed() {
    return const WatchedPressed();
  }

// ignore: unused_element
  CardPressed cardPressed() {
    return const CardPressed();
  }
}

/// @nodoc
// ignore: unused_element
const $MovieOrShowEvent = _$MovieOrShowEventTearOff();

/// @nodoc
mixin _$MovieOrShowEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult bookmarkPressed(),
    @required TResult watchedPressed(),
    @required TResult cardPressed(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult bookmarkPressed(),
    TResult watchedPressed(),
    TResult cardPressed(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult bookmarkPressed(BookmarkPressed value),
    @required TResult watchedPressed(WatchedPressed value),
    @required TResult cardPressed(CardPressed value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult bookmarkPressed(BookmarkPressed value),
    TResult watchedPressed(WatchedPressed value),
    TResult cardPressed(CardPressed value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $MovieOrShowEventCopyWith<$Res> {
  factory $MovieOrShowEventCopyWith(
          MovieOrShowEvent value, $Res Function(MovieOrShowEvent) then) =
      _$MovieOrShowEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$MovieOrShowEventCopyWithImpl<$Res>
    implements $MovieOrShowEventCopyWith<$Res> {
  _$MovieOrShowEventCopyWithImpl(this._value, this._then);

  final MovieOrShowEvent _value;
  // ignore: unused_field
  final $Res Function(MovieOrShowEvent) _then;
}

/// @nodoc
abstract class $BookmarkPressedCopyWith<$Res> {
  factory $BookmarkPressedCopyWith(
          BookmarkPressed value, $Res Function(BookmarkPressed) then) =
      _$BookmarkPressedCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarkPressedCopyWithImpl<$Res>
    extends _$MovieOrShowEventCopyWithImpl<$Res>
    implements $BookmarkPressedCopyWith<$Res> {
  _$BookmarkPressedCopyWithImpl(
      BookmarkPressed _value, $Res Function(BookmarkPressed) _then)
      : super(_value, (v) => _then(v as BookmarkPressed));

  @override
  BookmarkPressed get _value => super._value as BookmarkPressed;
}

/// @nodoc
class _$BookmarkPressed implements BookmarkPressed {
  const _$BookmarkPressed();

  @override
  String toString() {
    return 'MovieOrShowEvent.bookmarkPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BookmarkPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult bookmarkPressed(),
    @required TResult watchedPressed(),
    @required TResult cardPressed(),
  }) {
    assert(bookmarkPressed != null);
    assert(watchedPressed != null);
    assert(cardPressed != null);
    return bookmarkPressed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult bookmarkPressed(),
    TResult watchedPressed(),
    TResult cardPressed(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (bookmarkPressed != null) {
      return bookmarkPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult bookmarkPressed(BookmarkPressed value),
    @required TResult watchedPressed(WatchedPressed value),
    @required TResult cardPressed(CardPressed value),
  }) {
    assert(bookmarkPressed != null);
    assert(watchedPressed != null);
    assert(cardPressed != null);
    return bookmarkPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult bookmarkPressed(BookmarkPressed value),
    TResult watchedPressed(WatchedPressed value),
    TResult cardPressed(CardPressed value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (bookmarkPressed != null) {
      return bookmarkPressed(this);
    }
    return orElse();
  }
}

abstract class BookmarkPressed implements MovieOrShowEvent {
  const factory BookmarkPressed() = _$BookmarkPressed;
}

/// @nodoc
abstract class $WatchedPressedCopyWith<$Res> {
  factory $WatchedPressedCopyWith(
          WatchedPressed value, $Res Function(WatchedPressed) then) =
      _$WatchedPressedCopyWithImpl<$Res>;
}

/// @nodoc
class _$WatchedPressedCopyWithImpl<$Res>
    extends _$MovieOrShowEventCopyWithImpl<$Res>
    implements $WatchedPressedCopyWith<$Res> {
  _$WatchedPressedCopyWithImpl(
      WatchedPressed _value, $Res Function(WatchedPressed) _then)
      : super(_value, (v) => _then(v as WatchedPressed));

  @override
  WatchedPressed get _value => super._value as WatchedPressed;
}

/// @nodoc
class _$WatchedPressed implements WatchedPressed {
  const _$WatchedPressed();

  @override
  String toString() {
    return 'MovieOrShowEvent.watchedPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WatchedPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult bookmarkPressed(),
    @required TResult watchedPressed(),
    @required TResult cardPressed(),
  }) {
    assert(bookmarkPressed != null);
    assert(watchedPressed != null);
    assert(cardPressed != null);
    return watchedPressed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult bookmarkPressed(),
    TResult watchedPressed(),
    TResult cardPressed(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watchedPressed != null) {
      return watchedPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult bookmarkPressed(BookmarkPressed value),
    @required TResult watchedPressed(WatchedPressed value),
    @required TResult cardPressed(CardPressed value),
  }) {
    assert(bookmarkPressed != null);
    assert(watchedPressed != null);
    assert(cardPressed != null);
    return watchedPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult bookmarkPressed(BookmarkPressed value),
    TResult watchedPressed(WatchedPressed value),
    TResult cardPressed(CardPressed value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watchedPressed != null) {
      return watchedPressed(this);
    }
    return orElse();
  }
}

abstract class WatchedPressed implements MovieOrShowEvent {
  const factory WatchedPressed() = _$WatchedPressed;
}

/// @nodoc
abstract class $CardPressedCopyWith<$Res> {
  factory $CardPressedCopyWith(
          CardPressed value, $Res Function(CardPressed) then) =
      _$CardPressedCopyWithImpl<$Res>;
}

/// @nodoc
class _$CardPressedCopyWithImpl<$Res>
    extends _$MovieOrShowEventCopyWithImpl<$Res>
    implements $CardPressedCopyWith<$Res> {
  _$CardPressedCopyWithImpl(
      CardPressed _value, $Res Function(CardPressed) _then)
      : super(_value, (v) => _then(v as CardPressed));

  @override
  CardPressed get _value => super._value as CardPressed;
}

/// @nodoc
class _$CardPressed implements CardPressed {
  const _$CardPressed();

  @override
  String toString() {
    return 'MovieOrShowEvent.cardPressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CardPressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult bookmarkPressed(),
    @required TResult watchedPressed(),
    @required TResult cardPressed(),
  }) {
    assert(bookmarkPressed != null);
    assert(watchedPressed != null);
    assert(cardPressed != null);
    return cardPressed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult bookmarkPressed(),
    TResult watchedPressed(),
    TResult cardPressed(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cardPressed != null) {
      return cardPressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult bookmarkPressed(BookmarkPressed value),
    @required TResult watchedPressed(WatchedPressed value),
    @required TResult cardPressed(CardPressed value),
  }) {
    assert(bookmarkPressed != null);
    assert(watchedPressed != null);
    assert(cardPressed != null);
    return cardPressed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult bookmarkPressed(BookmarkPressed value),
    TResult watchedPressed(WatchedPressed value),
    TResult cardPressed(CardPressed value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cardPressed != null) {
      return cardPressed(this);
    }
    return orElse();
  }
}

abstract class CardPressed implements MovieOrShowEvent {
  const factory CardPressed() = _$CardPressed;
}

/// @nodoc
class _$MovieOrShowStateTearOff {
  const _$MovieOrShowStateTearOff();

// ignore: unused_element
  Initial initial() {
    return const Initial();
  }

// ignore: unused_element
  Bookmarked bookmarked() {
    return const Bookmarked();
  }

// ignore: unused_element
  Watched watched() {
    return const Watched();
  }

// ignore: unused_element
  NotBookmarked notBookmarked() {
    return const NotBookmarked();
  }

// ignore: unused_element
  NotWatched notWatched() {
    return const NotWatched();
  }
}

/// @nodoc
// ignore: unused_element
const $MovieOrShowState = _$MovieOrShowStateTearOff();

/// @nodoc
mixin _$MovieOrShowState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult bookmarked(),
    @required TResult watched(),
    @required TResult notBookmarked(),
    @required TResult notWatched(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult bookmarked(),
    TResult watched(),
    TResult notBookmarked(),
    TResult notWatched(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(Initial value),
    @required TResult bookmarked(Bookmarked value),
    @required TResult watched(Watched value),
    @required TResult notBookmarked(NotBookmarked value),
    @required TResult notWatched(NotWatched value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(Initial value),
    TResult bookmarked(Bookmarked value),
    TResult watched(Watched value),
    TResult notBookmarked(NotBookmarked value),
    TResult notWatched(NotWatched value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $MovieOrShowStateCopyWith<$Res> {
  factory $MovieOrShowStateCopyWith(
          MovieOrShowState value, $Res Function(MovieOrShowState) then) =
      _$MovieOrShowStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$MovieOrShowStateCopyWithImpl<$Res>
    implements $MovieOrShowStateCopyWith<$Res> {
  _$MovieOrShowStateCopyWithImpl(this._value, this._then);

  final MovieOrShowState _value;
  // ignore: unused_field
  final $Res Function(MovieOrShowState) _then;
}

/// @nodoc
abstract class $InitialCopyWith<$Res> {
  factory $InitialCopyWith(Initial value, $Res Function(Initial) then) =
      _$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialCopyWithImpl<$Res> extends _$MovieOrShowStateCopyWithImpl<$Res>
    implements $InitialCopyWith<$Res> {
  _$InitialCopyWithImpl(Initial _value, $Res Function(Initial) _then)
      : super(_value, (v) => _then(v as Initial));

  @override
  Initial get _value => super._value as Initial;
}

/// @nodoc
class _$Initial implements Initial {
  const _$Initial();

  @override
  String toString() {
    return 'MovieOrShowState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult bookmarked(),
    @required TResult watched(),
    @required TResult notBookmarked(),
    @required TResult notWatched(),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult bookmarked(),
    TResult watched(),
    TResult notBookmarked(),
    TResult notWatched(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(Initial value),
    @required TResult bookmarked(Bookmarked value),
    @required TResult watched(Watched value),
    @required TResult notBookmarked(NotBookmarked value),
    @required TResult notWatched(NotWatched value),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(Initial value),
    TResult bookmarked(Bookmarked value),
    TResult watched(Watched value),
    TResult notBookmarked(NotBookmarked value),
    TResult notWatched(NotWatched value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements MovieOrShowState {
  const factory Initial() = _$Initial;
}

/// @nodoc
abstract class $BookmarkedCopyWith<$Res> {
  factory $BookmarkedCopyWith(
          Bookmarked value, $Res Function(Bookmarked) then) =
      _$BookmarkedCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarkedCopyWithImpl<$Res>
    extends _$MovieOrShowStateCopyWithImpl<$Res>
    implements $BookmarkedCopyWith<$Res> {
  _$BookmarkedCopyWithImpl(Bookmarked _value, $Res Function(Bookmarked) _then)
      : super(_value, (v) => _then(v as Bookmarked));

  @override
  Bookmarked get _value => super._value as Bookmarked;
}

/// @nodoc
class _$Bookmarked implements Bookmarked {
  const _$Bookmarked();

  @override
  String toString() {
    return 'MovieOrShowState.bookmarked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Bookmarked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult bookmarked(),
    @required TResult watched(),
    @required TResult notBookmarked(),
    @required TResult notWatched(),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return bookmarked();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult bookmarked(),
    TResult watched(),
    TResult notBookmarked(),
    TResult notWatched(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (bookmarked != null) {
      return bookmarked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(Initial value),
    @required TResult bookmarked(Bookmarked value),
    @required TResult watched(Watched value),
    @required TResult notBookmarked(NotBookmarked value),
    @required TResult notWatched(NotWatched value),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return bookmarked(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(Initial value),
    TResult bookmarked(Bookmarked value),
    TResult watched(Watched value),
    TResult notBookmarked(NotBookmarked value),
    TResult notWatched(NotWatched value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (bookmarked != null) {
      return bookmarked(this);
    }
    return orElse();
  }
}

abstract class Bookmarked implements MovieOrShowState {
  const factory Bookmarked() = _$Bookmarked;
}

/// @nodoc
abstract class $WatchedCopyWith<$Res> {
  factory $WatchedCopyWith(Watched value, $Res Function(Watched) then) =
      _$WatchedCopyWithImpl<$Res>;
}

/// @nodoc
class _$WatchedCopyWithImpl<$Res> extends _$MovieOrShowStateCopyWithImpl<$Res>
    implements $WatchedCopyWith<$Res> {
  _$WatchedCopyWithImpl(Watched _value, $Res Function(Watched) _then)
      : super(_value, (v) => _then(v as Watched));

  @override
  Watched get _value => super._value as Watched;
}

/// @nodoc
class _$Watched implements Watched {
  const _$Watched();

  @override
  String toString() {
    return 'MovieOrShowState.watched()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Watched);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult bookmarked(),
    @required TResult watched(),
    @required TResult notBookmarked(),
    @required TResult notWatched(),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return watched();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult bookmarked(),
    TResult watched(),
    TResult notBookmarked(),
    TResult notWatched(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watched != null) {
      return watched();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(Initial value),
    @required TResult bookmarked(Bookmarked value),
    @required TResult watched(Watched value),
    @required TResult notBookmarked(NotBookmarked value),
    @required TResult notWatched(NotWatched value),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return watched(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(Initial value),
    TResult bookmarked(Bookmarked value),
    TResult watched(Watched value),
    TResult notBookmarked(NotBookmarked value),
    TResult notWatched(NotWatched value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watched != null) {
      return watched(this);
    }
    return orElse();
  }
}

abstract class Watched implements MovieOrShowState {
  const factory Watched() = _$Watched;
}

/// @nodoc
abstract class $NotBookmarkedCopyWith<$Res> {
  factory $NotBookmarkedCopyWith(
          NotBookmarked value, $Res Function(NotBookmarked) then) =
      _$NotBookmarkedCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotBookmarkedCopyWithImpl<$Res>
    extends _$MovieOrShowStateCopyWithImpl<$Res>
    implements $NotBookmarkedCopyWith<$Res> {
  _$NotBookmarkedCopyWithImpl(
      NotBookmarked _value, $Res Function(NotBookmarked) _then)
      : super(_value, (v) => _then(v as NotBookmarked));

  @override
  NotBookmarked get _value => super._value as NotBookmarked;
}

/// @nodoc
class _$NotBookmarked implements NotBookmarked {
  const _$NotBookmarked();

  @override
  String toString() {
    return 'MovieOrShowState.notBookmarked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NotBookmarked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult bookmarked(),
    @required TResult watched(),
    @required TResult notBookmarked(),
    @required TResult notWatched(),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return notBookmarked();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult bookmarked(),
    TResult watched(),
    TResult notBookmarked(),
    TResult notWatched(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notBookmarked != null) {
      return notBookmarked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(Initial value),
    @required TResult bookmarked(Bookmarked value),
    @required TResult watched(Watched value),
    @required TResult notBookmarked(NotBookmarked value),
    @required TResult notWatched(NotWatched value),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return notBookmarked(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(Initial value),
    TResult bookmarked(Bookmarked value),
    TResult watched(Watched value),
    TResult notBookmarked(NotBookmarked value),
    TResult notWatched(NotWatched value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notBookmarked != null) {
      return notBookmarked(this);
    }
    return orElse();
  }
}

abstract class NotBookmarked implements MovieOrShowState {
  const factory NotBookmarked() = _$NotBookmarked;
}

/// @nodoc
abstract class $NotWatchedCopyWith<$Res> {
  factory $NotWatchedCopyWith(
          NotWatched value, $Res Function(NotWatched) then) =
      _$NotWatchedCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotWatchedCopyWithImpl<$Res>
    extends _$MovieOrShowStateCopyWithImpl<$Res>
    implements $NotWatchedCopyWith<$Res> {
  _$NotWatchedCopyWithImpl(NotWatched _value, $Res Function(NotWatched) _then)
      : super(_value, (v) => _then(v as NotWatched));

  @override
  NotWatched get _value => super._value as NotWatched;
}

/// @nodoc
class _$NotWatched implements NotWatched {
  const _$NotWatched();

  @override
  String toString() {
    return 'MovieOrShowState.notWatched()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NotWatched);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult bookmarked(),
    @required TResult watched(),
    @required TResult notBookmarked(),
    @required TResult notWatched(),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return notWatched();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult bookmarked(),
    TResult watched(),
    TResult notBookmarked(),
    TResult notWatched(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notWatched != null) {
      return notWatched();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(Initial value),
    @required TResult bookmarked(Bookmarked value),
    @required TResult watched(Watched value),
    @required TResult notBookmarked(NotBookmarked value),
    @required TResult notWatched(NotWatched value),
  }) {
    assert(initial != null);
    assert(bookmarked != null);
    assert(watched != null);
    assert(notBookmarked != null);
    assert(notWatched != null);
    return notWatched(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(Initial value),
    TResult bookmarked(Bookmarked value),
    TResult watched(Watched value),
    TResult notBookmarked(NotBookmarked value),
    TResult notWatched(NotWatched value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notWatched != null) {
      return notWatched(this);
    }
    return orElse();
  }
}

abstract class NotWatched implements MovieOrShowState {
  const factory NotWatched() = _$NotWatched;
}
